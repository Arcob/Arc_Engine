#pragma once

#ifndef __RENDERING_OBJECT__
#define __RENDERING_OBJECT__

#include "common/common.h"

// This class holds the data for each vertex and all of its attributes and its equivalent OpenGL representation.
/*! \brief Stores the vertex data for a mesh. 
 *
 *  This class allows us to easily reuse the same mesh data for multiple objects in the scene.
 */
class RenderingObject
{
public:
    using PositionArray = std::vector<glm::vec4>;
    using IndexArray = std::vector<unsigned int>;
    using NormalArray = std::vector<glm::vec3>;
    using UVArray = std::vector<glm::vec2>;
    using ColorArray = std::vector<glm::vec4>;
    using TangentArray = std::vector<glm::vec3>;
    using BitangentArray = std::vector<glm::vec3>;

    /*! \brief This enum has its values corresponding to the layout location qualifer on the vertex attribute array.
     */
    enum class VertexAttributePositions {
        Position = 0,
        Normals,
        UV,
        Colors,
        Tangent,
        Bitangent
    };

    /*! \brief Constructs a RenderingObject from a shader and all the possible vertex attributes.
     *  \param inputShader The shader that is to be used to render this object. Can be a nullptr and set later.
     *  \param inputPositions The vertex positions. Should not be a null pointer (you can probably get away with it and set it later...).
     *  \param inputNormals The vertex normals. Can be set later.
     *  \param inputUV The vertex UV coordinates. Can be set later.
     *  \param inputColors The vertex colors. Can be set later.
     *
     *  Constructs a new object that holds the data necessary to render an object. Note that the ordering of the vertex attributes
     *  is the same regardless of whether or not the vertex attribute array is actually used by the shader. In other words, vertex UV's
     *  will always be at location 2 regardless of whether the vertex normals are set and/or used. Once the RenderingObject is created, the OpenGL
     *  VBO's and VAO's will be constructed and all available data will be copied into the OpenGL buffer.
     */
    RenderingObject(std::shared_ptr<class ShaderProgram> inputShader,
        std::unique_ptr<PositionArray> inputPositions,
        std::unique_ptr<IndexArray> inputIndices = nullptr,
        std::unique_ptr<NormalArray> inputNormals = nullptr,
        std::unique_ptr<UVArray> inputUV = nullptr,
        std::unique_ptr<ColorArray> inputColors = nullptr,
        std::unique_ptr<TangentArray> inputTangents  = nullptr,
        std::unique_ptr<BitangentArray> inputBitangents = nullptr);

    /*! \brief Just another deconstructor.
     */
    virtual ~RenderingObject();

    /*! \brief Sets the shader to be used to render this object.
     *
     *  Note that changing the shader for the rendering object will change the shader for ALL scene objects that use this rendering object.
     *  This function only modifies the 'shader' member variable.
     */
    virtual void SetShader(std::shared_ptr<class ShaderProgram> inputShader);

    /*! \brief Prepares to the mesh object.
     *
     *  We bind the vertex array object using <a href="https://www.opengl.org/sdk/docs/man/html/glBindVertexArray.xhtml">glBindVertexArray</a> 
     *  and the element buffer object so that OpenGL knows what to render.
     */
    virtual void BeginRender() const;

    /*! \brief Calls the appropriate draw function depending on whether or not an element buffer object is used.
     *
     *  Should an element buffer object exist, the right function to call is <a href="https://www.opengl.org/sdk/docs/man/html/glDrawElements.xhtml">glDrawElements</a>
     *  which will utilize the index data. Otherwise, we will call <a href="https://www.opengl.org/sdk/docs/man/html/glDrawArrays.xhtml">glDrawArrays</a>. This function
     *  will step through N vertices at a time and use those N vertices (in order) as the primitive to render. For example, if we are drawing triangles, then it will go
     *  through three vertices at a time to render a triangle.
     */
    virtual void Render() const;

    /*! \brief Unbinds the VAO and the EBO to cleanup the state.
     */
    virtual void EndRender() const;

    /*! \brief Sets what kind of primitives OpenGL should interpret the data as.
     *
     *  See the <a href="https://www.opengl.org/sdk/docs/man/html/glDrawArrays.xhtml">glDrawArrays</a> documentation for its 'mode' parameter to see what 
     *  values are valid.
     */
    void SetDrawMode(GLenum inputMode) {
        drawMode = inputMode;
    }

    /*! \brief Returns the OpenGL identifier for the underlying shader program.
     *  \returns Returns the value that was generated by <a href="https://www.opengl.org/sdk/docs/man/html/glCreateProgram.xhtml">glCreateProgram</a> for the underlying
     *   shader program.
     *  \warning If RenderingObject::shader is not set to a non-null pointer, this function's action is undefined.
     *
     *   
     */
    GLint GetShaderProgram() const;

    /*! \brief Returns a raw pointer to the underlying shader program.
     *  \returns Returns a raw pointer to the underlying shader program.
     *  \warning If RenderingObject::shader is not set to a non-null pointer, this function's action is undefined.
     *  \warning Do not store the ShaderProgram pointer anywhere. You may be left with a dangling pointer at some point.
     */
    const class ShaderProgram* GetShaderProgramRaw() const;

    /*! \brief Returns the total number of vertices.
     *  \returns Returns the total number of vertices.
     *  \warning The vertex position array must be set before this is called.
     */
    size_t GetTotalVertices() const
    {
        return vertexPositions->size();
    }

    /*! \brief Sets the vertex positions array. Also updates the data stored in the vertex buffer object.
     */
    virtual void SetVertexPositions(std::unique_ptr<PositionArray> positions);

    /*! \brief Sets the vertex indices array. Also updates the data stored in the element buffer object.
     */
    virtual void SetVertexIndices(std::unique_ptr<IndexArray> indices);

    /*! \brief Sets the vertex normal array. Also updates the data stored in the vertex buffer object.
     */
    virtual void SetVertexNormals(std::unique_ptr<NormalArray> normals);

    /*! \brief Sets the vertex UV array. Also updates the data stored in the vertex buffer object.
     */
    virtual void SetVertexUV(std::unique_ptr<UVArray> uv);

    /*! \brief Sets the vertex color array. Also updates the data stored in the vertex buffer object.
     */
    virtual void SetVertexColors(std::unique_ptr<ColorArray> colors);

    virtual void SetVertexTangents(std::unique_ptr<TangentArray> input);
    virtual void SetVertexBitangents(std::unique_ptr<BitangentArray> input);

    virtual void ComputeTangentSpace();
    virtual void ReverseNormals();
    virtual void ReverseVertexOrder();

private:
    virtual void ComputeTangentSpaceHelper(glm::ivec3 triangleVertexIndices, bool useStoredNormals, std::vector<int>& averager);

protected:
    /*! \brief The shader program used to render the object.
     *
     *  This should be set on construction or set later. However, this should be set before the RenderingObject is rendered. 
     */
    std::shared_ptr<class ShaderProgram> shader;

    /*! \brief The buffer ID for the vertex position VBO as generated by <a href="https://www.opengl.org/sdk/docs/man/html/glGenBuffers.xhtml">glGenBuffers</a>.
     */
    GLuint vertexPositionBuffer;

    /*! \brief The position of every vertex.
     */
    std::unique_ptr<PositionArray> vertexPositions;

    /*! \brief The buffer ID for the vertex index EBO as generated by <a href="https://www.opengl.org/sdk/docs/man/html/glGenBuffers.xhtml">glGenBuffers</a>.
     */
    GLuint vertexIndexBuffer;

    /*! \brief The indices into the vertex array. This allows us to reuse vertices for multiple faces.
     */
    std::unique_ptr<IndexArray> vertexIndices;

    /*! \brief The buffer ID for the vertex normal VBO as generated by <a href="https://www.opengl.org/sdk/docs/man/html/glGenBuffers.xhtml">glGenBuffers</a>.
     */
    GLuint vertexNormalBuffer;

    /*! \brief The normal of every vertex.
     */
    std::unique_ptr<NormalArray> vertexNormals;

    GLuint vertexTangentBuffer;
    std::unique_ptr<TangentArray> vertexTangents;

    GLuint vertexBitangentBuffer;
    std::unique_ptr<BitangentArray> vertexBitangents;

    /*! \brief The default value sent to the shader if RenderingObject::vertexNormals is not set. 
     *
     *  The <a href="https://www.opengl.org/sdk/docs/man/html/glVertexAttrib.xhtml">glVertexAttrib</a> function is used to set the default value.
     */
    static glm::vec3 DEFAULT_NORMAL;

    /*! \brief The buffer ID for the vertex UV VBO as generated by <a href="https://www.opengl.org/sdk/docs/man/html/glGenBuffers.xhtml">glGenBuffers</a>.
     */
    GLuint vertexUVBuffer;

    /*! \brief The UV coordinate of every vertex.
     */
    std::unique_ptr<UVArray> vertexUV;

    /*! \brief The default value sent to the shader if RenderingObject::vertexUV is not set. 
     *
     *  The <a href="https://www.opengl.org/sdk/docs/man/html/glVertexAttrib.xhtml">glVertexAttrib</a> function is used to set the default value.
     */
    static glm::vec2 DEFAULT_UV;

    /*! \brief The buffer ID for the vertex color VBO as generated by <a href="https://www.opengl.org/sdk/docs/man/html/glGenBuffers.xhtml">glGenBuffers</a>.
     */
    GLuint vertexColorBuffer;
    
    /*! \brief The color of every vertex.
     */
    std::unique_ptr<ColorArray> vertexColors;

    /*! \brief The default value sent to the shader if RenderingObject::vertexColors is not set. 
     *
     *  The <a href="https://www.opengl.org/sdk/docs/man/html/glVertexAttrib.xhtml">glVertexAttrib</a> function is used to set the default value.
     */
    static glm::vec4 DEFAULT_COLOR;

    /*! \brief Prepares the rendering object for use by OpenGL.
     *
     *  This function calls all of the UpdateVertex functions. Additionally, it generates the vertex array object. Note that this function should only be called once.
     */
    virtual void InitializeOpenGL();
    
    virtual void UpdateVertexPositions();
    virtual void UpdateVertexIndices();
    virtual void UpdateVertexNormals();
    virtual void UpdateVertexUV();
    virtual void UpdateVertexColors();
    virtual void UpdateVertexTangents();
    virtual void UpdateVertexBitangents();

    virtual void CleanupVertexPositions();
    virtual void CleanupVertexIndices();
    virtual void CleanupVertexNormals();
    virtual void CleanupVertexUV();
    virtual void CleanupVertexColors();
    virtual void CleanupVertexTangents();
    virtual void CleanupVertexBitangents();

    GLuint vao;
    GLenum drawMode;
};

#endif
